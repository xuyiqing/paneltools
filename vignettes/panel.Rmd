---
title: 'Tutorial for Causal Panel Analysis'
author: Ziyi Liu and Yiqing Xu
output:
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: false
    toc_depth: 3
    number_sections: false
    theme: lumen
bibliography: tscs_references.bib      
vignette: >
  %\VignetteIndexEntry{Tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
---
<!-- 
  Code to Justify Text
    <style>
    body {
    text-align: justify}
    </style>
-->   
```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```  

In recent years, researchers have proposed various robust estimators for heterogeneous treatment effects (HTE) in causal panel analysis as an alternative to traditional two-way fixed effects (TWFE) models. Examples of these estimators include those proposed by @sun2021-event, @callaway2021-did, @LWX2022, @BJS2021, and @IKW2021. This tutorial will guide you through the implementation of these HTE-robust estimators, as well as TWFE, using R. It will also provide instructions on how to create event study plots that display estimated dynamic treatment effects. Additionally, this tutorial will present a recommended pipeline for analyzing panel data, covering data exploration, estimation, result visualization, and diagnostic tests. To begin, you will need to install necessary packages from CRAN and Github. The tutorial will then provide two empirical examples, based on @hainmueller2019does and @Grumbach2020, to illustrate these methods.

# Installing Packages

```{r message = FALSE, warning = FALSE, echo = FALSE}
#path <- "~/Dropbox/ProjectZ/TSCS_practice/data/cleaned/"
# path <- "D:/Dropbox/TSCS_practice/data/cleaned/"
```

```{r message = FALSE, warning = FALSE}
# install packages from CRAN
packages <- c("dplyr", "readstata13", "fixest", "did", "fect", "didimputation",
              "panelView", "PanelMatch", "ggplot2", "bacondecomp", "HonestDiD")
install.packages(setdiff(packages, rownames(installed.packages())),
                 repos = "https://cloud.r-project.org")  

# install "HonestDID"
if ("HonestDID" %in% rownames(installed.packages()) == FALSE) {
  devtools:: install_github("asheshrambachan/HonestDiD")
}  

# update "fect"
devtools:: install_github("xuyiqing/fect", upgrade = "always")
  

# install "paneltools"
if ("paneltools" %in% rownames(installed.packages()) == FALSE) {
  devtools:: install_github("xuyiqing/paneltools")
}
```

```{r message = FALSE, warning = FALSE}
library(dplyr)
library(readstata13)
library(fixest)
library(did)
library(fect)
library(panelView)
library(PanelMatch)
library(ggplot2)
library(bacondecomp)
library(paneltools)
library(didimputation)
library(doParallel)
library(HonestDiD)
```

Lood data:
```{r data}
data(paneltools)
ls()
summary(hh2019)
summary(gs2020)
```

#  Example 1: w/o Treatment Reserveal

We begin with an empirical example from Hainmueller and Hopkins (2019), in which the authors investigate the effects of indirect democracy (versus direct democracy) on naturalization rates in Switzerland using municipality-year level panel data from 1991 to 2009. The study shows that a switch from direct to indirect democracy increased naturalization rates by an average of 1.22 percentage points (Model 1 of Table 1 in the paper).

```{r message = FALSE, warning = FALSE}
data <- hh2019
head(data)
```

##  Data Visualization

First, we will examine the evolution of treatment status using the **panelView** package. The variables `bfs` and `year` are the unit and time indicators, respectively. The treatment variable is `indirect`, and the outcome is `nat_rate_ord`. In the baseline analysis, we will not include any covariates. We will set the option `by.timing = TRUE` to sort units by the timing of receiving the treatment.

```{r hh_panelview_treat, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=TRUE}
panelview(nat_rate_ord ~ indirect, data = data, index = c("bfs","year"), 
  xlab = "Year", ylab = "Unit", display.all = T,
  gridOff = TRUE, by.timing = TRUE)
```

The treatment status plot shows that the treatment rolls out in different years for different municipalities and there are no treatment reversals (staggered adoption). Following the definition in @sun2021-event, we define the units that take the treatment in the same year as a cohort. We can plot the average outcomes for each cohort using **panelView**.

```{r hh_panelview_cohort, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5,cache=TRUE}
panelview(data = data,Y='nat_rate_ord',
          D='indirect',index=c("bfs","year"),
          by.timing = T, display.all = T,
          type = "outcome",by.cohort = T)
```

## TWFE

The staggered adoption setup allows us to implement several estimators to obtain the treatment effect estimates. We will first estimate a two-way fixed-effects (TWFE) model, as the authors do in the paper: $$Y_{it} = \alpha_i + \xi_t + \delta^{TWFE}D_{it} + \epsilon$$ We can implement this estimator using the command **feols** in the **fixest package. The estimated coefficient using TWFE is 1.339, with a standard error of 0.187.

```{r hh_twfe1, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5}
model.twfe.0 <- feols(nat_rate_ord~indirect|bfs+year,
                      data=data, cluster = "bfs") #use the clustered standard error
print(model.twfe.0)
```


##  Goodman-Bacon Decomposition

@Goodman-Bacon2021-xb demonstrates that the two-way fixed-effects (TWFE) estimator in a staggered adoption setting can be represented as a weighted average of all possible 2x2 difference-in-differences (DID) estimates between different cohorts. However, when treatment effects change over time heterogeneously across cohorts, the "forbidden" comparisons that use post-treatment data from early adopters as controls for late adopters may introduce bias in the TWFE estimator. We employ the procedure outlined in @Goodman-Bacon2021-xb and decompose the TWFE estimate using the command `bacon` in the **bacondecomp** package.

```{r hh_bacon, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=TRUE}
data.complete <- data[which(!is.na(data$nat_rate_ord)),] # bacon requires no missingness in the data
df_bacon <- bacon(nat_rate_ord~indirect,
                  data = data.complete,
                  id_var = "bfs",
                  time_var = "year")
ggplot(df_bacon) +
   aes(x = weight, y = estimate, shape = factor(type), color = factor(type)) +
   labs(x = "Weight", y = "Estimate", shape = "Type", color = 'Type') +
   geom_point()
print(aggregate(df_bacon$estimate * df_bacon$weight, list(df_bacon$type), FUN=sum))
```

The decomposition of the TWFE estimator in a staggered adoption setting by @Goodman-Bacon2021-xb shows that the estimates from the DIDs comparing ever-treated cohorts switching into treatment with the never-treated (purple crosses labeled "Treated vs Untreated") contribute the most to the TWFE estimate. The DIDs comparing ever-treated cohorts switching into treatment and other ever-treated cohorts that are still in their pretreatment periods (the red dots labeled "Earlier vs Later Treated") and the "forbidden" comparisons between ever-treated cohorts and the always-treated (green triangles labeled "Later vs Always Treated") rank second and third in terms of their contribution. The "forbidden" DIDs comparing ever-treated cohorts switching into treatment and other ever-treated cohorts that are already treated (the blue squares labeled "Later vs Earlier Treated") contribute the least to the TWFE estimate.

Additionally, to further address the issue of heterogeneous treatment effects across cohorts, we can use methods specifically designed to handle heterogeneous treatment effects, such as the methods outlined in @sun2021-event, @callaway2021-did, and @LWX2022. These methods can provide robust causal estimates that take into account the heterogeneous nature of treatment effects across different cohorts. By using these methods, we can better account for the potential bias introduced by the "forbidden" comparisons and obtain more accurate estimates of the treatment effects.

```{r hh_twfe2, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
# drop always treated units
df <- as.data.frame(data %>% group_by(bfs) %>% mutate(treatment_mean = mean(indirect,na.rm = TRUE)))
df.use <- df[which(df$treatment_mean<1),]

# Re-estimate TWFE on this Sub-sample
model.twfe.1 <- feols(nat_rate_ord~indirect|bfs+year,
                      data=df.use, cluster = "bfs")
print(model.twfe.1)
```

After removing the always-treated units, the estimated average treatment effect (ATT) increases to 1.609, with a standard error of 0.195. However, to fully address the bias caused by heterogeneous treatment effects (HTE), it is necessary to eliminate the "forbidden comparisons" through the use of HTE-robust estimators. Before implementing these estimators, we will demonstrate how to create an event study plot using a TWFE model with a dynamic specification.

## Event Study Plot for TWFE

In order to create an event study plot, we must first generate the cohort index and the relative time period for each observation in relation to treatment. These details are essential for various HTE-robust estimators, such as @sun2021-event and @callaway2021-did. We can use the function `get.cohort` in the package **paneltools** to generate these indices. Notably, in order to maintain consistency with canonical TWFE regressions, we specify the `start0` option as `TRUE`, thereby designating period $0$ as the first post-treatment period, while period $-1$ represents the last pre-treatment period.

```{r hh_cohort, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
df.use <- get.cohort(df.use,D="indirect",index=c("bfs","year"),start0 = TRUE)
head(df.use[,-5],19)
```

The variable `FirstTreat` indicates the first period when a unit gets treated (for never-treated units, `FirstTreat` is set to `NA`), and the variable `Time_to_Treatment` indicates the relative period to the treatment's onset (for always-treated and never-treated units, `Time_to_Treatment` is set to `NA`). The period `-1` corresponds to the last pre-treatment period.

We first use the dynamic TWFE regression, which is the workhorse model to estimate dynamic treatment effects in event studies, to create the event study plot. This model includes a series of interaction terms between a dummy that indicates whether a unit is a treated unit and each lead (lag) indicator relative to the treatment in a TWFE regression. This specification allows for effects to vary over time and usually uses the period immediately preceding a switch into the treatment as the reference period. If the regression is saturated and there is no heterogeneous treatment effects across cohorts, this dynamic TWFE can consistently estimate the dynamic treatment effect.

We still use the function `feols` to implement this estimator. The variable `Time_to_Treatment` can serve as the lead (lag) indicator (we need to replace the `NA` in `Time_to_Treatment` with an arbitrary number). Note that the period `-1` in `Time_to_Treatment` corresponds to the last pre-treatment period and is the reference period.

```{r hh_twfeplot, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
# TWFE Dynamic
df.twfe <- df.use
df.twfe$treat <- as.numeric(df.twfe$treatment_mean>0) # drop always treated units
df.twfe[which(is.na(df.twfe$Time_to_Treatment)),'Time_to_Treatment'] <- 0 # can be an arbitrary value
twfe.est <- feols(nat_rate_ord ~ i(Time_to_Treatment, treat, ref = -1)| bfs + year,  
                  data = df.twfe, cluster = "bfs")
twfe.output <- as.matrix(twfe.est$coeftable)
print(twfe.output)
```

The **paneltools** package offers a useful function, `esplot()`, that can be utilized to effectively visualize results. In this instance, we utilize the function to examine the dynamic effects over a 13 period pre-treatment span and a 10 period post-treatment span. The data reveals a significant impact of the treatment, as well as a subtle pre-trend discrepancy in a number of periods preceding the treatment. It is noteworthy that `esplot()` considers period $0$ to be the last pre-treatment period by default, so it is necessary to shift the period index by one. 

```{r hh_twfeplot2, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=TRUE}
twfe.output <- as.data.frame(twfe.output)
twfe.output$Time <- c(c(-18:-2),c(0:17))+1 
p.twfe <- esplot(twfe.output,Period = 'Time',Estimate = 'Estimate',
                               SE = 'Std. Error', xlim = c(-12,10))
p.twfe
```


In addition, by setting the `start0` option to `TRUE`, we have the flexibility to designate period $0$ as the first post-treatment period, thereby rendering period $-1$ as the last pre-treatment period. Consequently, there is no requirement to shift the period index by one in this scenario, as it aligns with the conventional TWFE framework.

```{r hh_twfeplot3, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=FALSE}
twfe.output <- as.data.frame(twfe.est$coeftable)
twfe.output$Time <- c(c(-18:-2),c(0:17)) 
p.twfe <- esplot(twfe.output,Period = 'Time',Estimate = 'Estimate',
                               SE = 'Std. Error', xlim = c(-12,10),start0 = TRUE)
p.twfe
```


## Stacked DID

The study, @CDLZ, examines the effect of variations in minimum wage on low-wage employment across 138 state-level minimum wage changes in the United States between 1979 and 2016, utilizing a stacked difference-in-differences (DID) approach. A similar estimator is also implemented in the Stata package STACKEDEV, as per @STACKEDEV. This stacked DID method eliminates the bias resulted from "forbidden" comparisons in the Goodman-Bacon decomposition. However, it still relies on the implicit weights chosen by OLS, making it less robust in terms of heterogeneous treatment effects (HTE) and less interpretable compared to other HTE-robust estimators.

The study employs a stacked difference-in-differences approach to estimate the impact of minimum wage changes on low-wage jobs across a series of 138 state-level minimum wage changes between 1979 and 2016 in the United States. For each ever-treated cohort, a cohort-specific dataset is created, comprising of the cohort and all never-treated units. These cohort-specific datasets are then stacked in order to calculate an average effect across all cohorts by utilizing fixed effects regression, while controlling for stack-unit interaction fixed effects and stack-year interaction fixed effects. With this stacked cohort-specific dataset, dynamic treatment effects can be obtained in a similar way as with the TWFE estimator.

```{r hh_st, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
df.st <- NULL
target.cohorts <- setdiff(unique(df.use$Cohort),"Control")
k <- 1
for(cohort in target.cohorts){
  df.sub <- df.use[which(df.use$Cohort%in%c(cohort,"Control")),]
  df.sub$stack <- k
  df.st <- rbind(df.st,df.sub)
  k <- k + 1
}
df.st$st_unit <- as.numeric(factor(paste0(df.st$stack,'-',df.st$bfs)))
df.st$st_year <- as.numeric(factor(paste0(df.st$stack,'-',df.st$year)))
model.st <- feols(nat_rate_ord~indirect|st_unit+st_year,
                  data=df.st, cluster = "st_unit")
print(model.st)
```

### Event Study Plot

```{r hh_stplot, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
df.st$treat <- as.numeric(df.st$treatment_mean>0)
df.st[which(is.na(df.st$Time_to_Treatment)),'Time_to_Treatment'] <- 0 # can be arbitrary value
st.est <- feols(nat_rate_ord ~ i(Time_to_Treatment, treat, ref = -1)| st_unit + st_year,data = df.st,cluster = "st_unit")
print(st.est$coeftable)
```

```{r hh_stplot2, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=FALSE}
st.output <- as.data.frame(st.est$coeftable)
st.output$Time <- c(c(-18:-2),c(0:17))+1 
p.st <- esplot(st.output,Period = 'Time',Estimate = 'Estimate',
                               SE = 'Std. Error', xlim = c(-12,10))
p.st
```

## Interaction Weighted

In the study @sun2021-event, an interaction-weighted (iw) estimator is proposed as a means of estimating heterogeneous treatment effects. This estimator is a weighted average of the average treatment effect (ATT) estimates for each cohort, obtained from a TWFE regression that includes cohort dummies fully interacted with indicators of relative time to the treatment's onset. The iw estimator is robust to heterogeneous treatment effects (HTE) and can be implemented using the command `sunab` in the package **fixest**. The variable `FirstTreat` serves as the cohort indicator, and any missing values in this variable should be replaced with an arbitrary number. The estimated ATT obtained using the iw estimator is 1.331, with a standard error of 0.288.

```{r hh_sa, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
df.sa <- df.use
df.sa[which(is.na(df.sa$FirstTreat)),"FirstTreat"] <- 1000 # replace NA with an arbitrary number 
model.sa.1 <- feols(nat_rate_ord~sunab(FirstTreat,year)|bfs+year,
                    data = df.sa, cluster = "bfs")
summary(model.sa.1,agg = "ATT")
```

### Event Study Plot

The results of this estimation are saved in the object `coeftable` for further analysis.

```{r hh_saplot, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
sa.output <- as.matrix(model.sa.1$coeftable)
print(sa.output)
```

We can visualize the estimated dynamic treatment effects using the same method as we do for the TWFE estimator. The results indicate a significant treatment effect, but no pre-treatment trend difference is observed. The minimal difference between the results obtained from the TWFE and iw estimators suggests that the weak pre-treatment trend difference may be a result of heterogeneous treatment effects rather than a violation of the parallel trend assumption.

```{r hh_saplot2, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=FALSE}
sa.output <- as.data.frame(sa.output)
sa.output$Time <- c(c(-18:-2),c(0:17))+1
p.sa <- esplot(sa.output,Period = 'Time',Estimate = 'Estimate',
                             SE = 'Std. Error', xlim = c(-12,10))
p.sa
```


## CSDID

@callaway2021-did proposed a doubly-robust estimator, referred to as csdid, that incorporates pre-treatment covariates by using either never-treated or not-yet-treated units as the comparison group. In this tutorial, we will only be utilizing the outcome model instead of the double-robust model to calculate the ATT and dynamic treatment effects.

First, we use the never-treated units as the comparison group. The variable `FirstTreat` serves as the cohort indicator, where we replace the missing values in `FirstTreat` with 0. The estimated ATT is numerically the same as the iw estimator. Additionally, we set the option `bstrap` to `FALSE` in order to report the analytical standard error, which is 0.302.

```{r hh_cs1, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
df.cs <- df.use
df.cs[which(is.na(df.cs$FirstTreat)),"FirstTreat"] <- 0 # replace NA with 0
cs.est.1 <- att_gt(yname = "nat_rate_ord",
                 gname = "FirstTreat",
                 idname = "bfs",
                 tname = "year",
                 xformla = ~1,
                 control_group = "nevertreated",
                 allow_unbalanced_panel = TRUE,
                 data = df.cs,
                 est_method = "reg")
cs.est.att.1 <- aggte(cs.est.1, type = "simple", na.rm=T, bstrap = F)
print(cs.est.att.1)
```


### Event Study Plot

The csdid estimator utilizes the command `aggte` to aggregate the cohort-period average treatment effects. We set the option `bstrap` to `FALSE` to report analytical standard errors and the option `cband` to `FALSE` to report period-wise confidence intervals. This allows for easy comparison with other estimators. Note that the `aggte` command also has the capability to compute uniform confidence bands by setting `cband` and `bstrap` to `TRUE`, but in this case we chose to report period-wise intervals.

```{r hh_csplot1, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
cs.att.1 <- aggte(cs.est.1, type = "dynamic",
                  bstrap=FALSE, cband=FALSE, na.rm=T) 
print(cs.att.1)
```

The estimated dynamic treatment effects during the post-treatment period are numerically the same as those obtained from the iw estimator. However, the estimates for the pre-treatment period may differ as the csdid estimator does not rely on a single reference period. We present the results in a similar manner and it can be observed that there is a significant treatment effect present, with no clear pre-trend difference.

```{r hh_csplot1a, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=FALSE}
cs.output <- cbind.data.frame(Estimate = cs.att.1$att.egt,
                              SE = cs.att.1$se.egt,
                              time = cs.att.1$egt + 1)
p.cs.1 <- esplot(cs.output,Period = 'time',Estimate = 'Estimate',
                               SE = 'SE', xlim = c(-12,10))
p.cs.1
```

The package also offers an option, 'base_period = universal', which sets the base period to always be the last pre-treatment period. This produces results that are quite similar to the iw estimator.

```{r hh_csplot1b, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=FALSE}
cs.est.1.u <- att_gt(yname = "nat_rate_ord",
                 gname = "FirstTreat",
                 idname = "bfs",
                 tname = "year",
                 xformla = ~1,
                 control_group = "nevertreated",
                 allow_unbalanced_panel = TRUE,
                 data = df.cs,
                 est_method = "reg", 
                 base_period = "universal")
cs.att.1.u <- aggte(cs.est.1.u, type = "dynamic",
                    bstrap=FALSE, cband=FALSE, na.rm=T) 
cs.output.u <- cbind.data.frame(Estimate = cs.att.1.u$att.egt,
                                SE = cs.att.1.u$se.egt,
                                time = cs.att.1.u$egt + 1)
p.cs.1.u <- esplot(cs.output.u,Period = 'time',Estimate = 'Estimate',
                               SE = 'SE', xlim = c(-12,10))
p.cs.1.u
```



We can also use the **not-yet-treated** units as the comparison group by setting `control_group = "notyettreated"`. The choice of the comparison group depends on the specific version of the parallel trend assumption that researchers need to justify. The estimated ATT is 1.292, with a standard error of 0.308.

```{r hh_cs2, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
cs.est.2 <- att_gt(yname = "nat_rate_ord",
                   gname = "FirstTreat",
                   idname = "bfs",
                   tname = "year",
                   xformla = ~1,
                   control_group = "notyettreated",
                   allow_unbalanced_panel = TRUE,
                   data = df.cs,
                   est_method = "reg")
cs.est.att.2 <- aggte(cs.est.2, type = "simple",na.rm=T, bstrap = F)
print(cs.est.att.2)
```

We can calculate the dynamic treatment effects using the same method.

```{r hh_csplot2, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=TRUE}
cs.att.2 <- aggte(cs.est.2, type = "dynamic",
                  bstrap=FALSE,cband=FALSE,na.rm=T) 
print(cs.att.2)
```


```{r hh_csplot2a, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=FALSE}
cs.output <- cbind.data.frame(Estimate = cs.att.2$att.egt,
                              SE = cs.att.2$se.egt,
                              time = cs.att.2$egt + 1)
p.cs.2 <- esplot(cs.output,Period = 'time',Estimate = 'Estimate',
                               SE = 'SE', xlim = c(-12,10))
p.cs.2
```

And we can set the reference period to be the last pre-treatment period.

```{r hh_csplot2b, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=FALSE}
cs.est.2.u <- att_gt(yname = "nat_rate_ord",
                 gname = "FirstTreat",
                 idname = "bfs",
                 tname = "year",
                 xformla = ~1,
                 control_group = "notyettreated",
                 allow_unbalanced_panel = TRUE,
                 data = df.cs,
                 est_method = "reg", 
                 base_period = "universal")
cs.att.2.u <- aggte(cs.est.1.u, type = "dynamic",
                    bstrap=FALSE, cband=FALSE, na.rm=T) 
cs.output.u <- cbind.data.frame(Estimate = cs.att.2.u$att.egt,
                                SE = cs.att.2.u$se.egt,
                                time = cs.att.2.u$egt + 1)
p.cs.2.u <- esplot(cs.output.u,Period = 'time',Estimate = 'Estimate',
                               SE = 'SE', xlim = c(-12,10))
p.cs.2.u
```

## PanelMatch

In @IKW2021, a matching framework is proposed as a generalization of the difference-in-differences estimator. This framework allows researchers to match each treated observation for a given unit in a particular period with untreated observations from other units in the same period that have similar treatment, outcome, or covariate histories.

The `PanelMatch` command can be utilized to create these matched sets. The option `lag = 3` indicates that the pre-treatment history periods to be matched on should have a length of 3, while the option `lead = c(0:3)` specifies that the lead window should be four post-treatment periods. To assign equal weights to all control units in each matched set, the option `refinement.method="none"` is set. It is important to note that by matching on treatment history and specifying the lead window, the `PanelMatch` command only uses a subset of treated units that have 3 pre-treatment periods and 4 post-treatment periods to compute the average treatment effects.

The PanelMatch estimator is also equivalent to the $DID_{M}$ estimator proposed by @CDH2020 if we only match on the last pre-treatment period and only estimate the treatment effect at the first post-treatment period.

```{r hh_pm, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
df.pm <- df.use
# we need to convert the unit and time indicator to integer
df.pm[,"bfs"] <- as.integer(as.factor(df.pm[,"bfs"]))
df.pm[,"year"] <- as.integer(as.factor(df.pm[,"year"]))
df.pm <- df.pm[,c("bfs","year","nat_rate_ord","indirect")]

PM.results <- PanelMatch(lag=3, 
                         time.id="year", 
                         unit.id = "bfs", 
                         treatment = 'indirect', 
                         refinement.method = "none", 
                         data = df.pm, 
                         qoi = "att", 
                         lead = c(0:3), 
                         outcome.var = 'nat_rate_ord', 
                         match.missing = TRUE)

## For pre-treatment dynamic effects
PM.results.placebo <- PanelMatch(lag=3, 
                         time.id="year", 
                         unit.id = "bfs", 
                         treatment = 'indirect', 
                         refinement.method = "none", 
                         data = df.pm, 
                         qoi = "att", 
                         lead = c(0:3), 
                         outcome.var = 'nat_rate_ord', 
                         match.missing = TRUE,
                         placebo.test = TRUE)

```

We can estimate the ATT and dynamic treatment effects using the command `PanelEstimate`. To obtain the ATT, we set the option `pooled = TRUE`. The standard error is calculated using a block bootstrapping method.

```{r hh_pm1, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
# ATT
PE.results.pool <- PanelEstimate(PM.results, data = df.pm, pooled = TRUE)
summary(PE.results.pool)
```

### Event Study Plot

We can also use the command `PanelEstimate` to estimate the dynamic treatment effects at post-treatment periods. Additionally, for pre-treatment periods, **PanelMatch** offers the command `placebo_test` to compute the change in outcomes for each pre-treatment period in the lag window compared to the last pre-treatment period.

```{r hh_pm2, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
# Dynamic Treatment Effects
PE.results <- PanelEstimate(PM.results, data = df.pm)
PE.results.placebo <- placebo_test(PM.results.placebo, data = df.pm, plot = F)
```

```{r hh_pm3, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=FALSE}
est_lead <- as.vector(PE.results$estimates)
est_lag <- as.vector(PE.results.placebo$estimates)
sd_lead <- apply(PE.results$bootstrapped.estimates,2,sd)
sd_lag <- apply(PE.results.placebo$bootstrapped.estimates,2,sd)
coef <- c(est_lag, 0, est_lead)
sd <- c(sd_lag, 0, sd_lead)
pm.output <- cbind.data.frame(ATT=coef, se=sd, t=c(-2:4))
p.pm <- esplot(data = pm.output,Period = 't',
               Estimate = 'ATT',SE = 'se')
p.pm
```


## Imputation Method

@LWX2022 proposes a method for estimating the fixed effect counterfactual model by utilizing the untreated observations. The model, represented by the equation $Y_{it} = \alpha_i + \xi_t + \delta^{TWFE}D_{it} + \epsilon$, estimates the parameters $\alpha_{i}$ and $\xi_{t}$ using only untreated observations and imputes the counterfactual using the estimated values of $\hat{\alpha}_{i}$ and $\hat{\xi}_{t}$. This method, independently proposed by @BJS2021 and @gardnertwo, is also referred to as the "imputation method" or "two-stage DID," respectively. To implement this estimator, the fe (fixed effects) method in the fect package can be utilized. The estimated average treatment effect (ATT) is 1.506, with a standard error of 0.197.

```{r hh_fect, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
out.fect <- fect(nat_rate_ord~indirect, data = df, 
                 index = c("bfs","year"),
                 method = 'fe', se = TRUE)
print(out.fect$est.avg)
```

The fect function stores the estimated dynamic treatment effects that are obtained using the counterfactual method in the object `est.att`. The uncertainty estimates for these estimates are obtained through a nonparametric clustered bootstrap procedure.

```{r hh_fectplot, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
fect.output <- as.matrix(out.fect$est.att)
print(fect.output)
```

@BJS2021 also provides a package `didimputation` to calculate the average treatment effect in the same way as @LWX2022.

```{r hh_impute, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
df.impute <- df.use
df.impute[which(is.na(df.impute$FirstTreat)),"FirstTreat"] <- 0 # replace NA with 0
out.impute <- did_imputation(data = df.impute,
                               yname = "nat_rate_ord",
                               gname = "FirstTreat",
                               tname = "year",
                               idname = "bfs",
                               cluster_var = "bfs")
out.impute
```


### Event Study Plot

We can visualize the dynamic treatment effects in the same way.

```{r hh_fectplot2, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=FALSE}
fect.output <- as.data.frame(fect.output)
fect.output$Time <- c(-17:18)
p.fect <- esplot(fect.output,Period = 'Time',Estimate = 'ATT',
                   SE = 'S.E.',CI.lower = "CI.lower", 
                   CI.upper = 'CI.upper',xlim = c(-12,10))
p.fect
```

The **didimputation** package also supports the event study estimate, which produces a numerically equivalent estimate for the dynamic treatment effects post-treatment. However, `didimputation` uses a distinct TWFE-regression solely on untreated observations to obtain the pre-treatment estimates and conduct a test for parallel trends. In this case, we can specify the option `pretrends = c(-13:-1)` to compute the regression coefficients for the pre-treatment periods ranging from -13 to -1.

```{r hh_impute2, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=FALSE}
model.impute <- did_imputation(data = df.impute,
                               yname = "nat_rate_ord",
                               gname = "FirstTreat",
                               tname = "year",
                               idname = "bfs",
                               cluster_var = "bfs",
                               pretrends = c(-13:-1),
                               horizon = TRUE)
model.impute$term <- as.numeric(model.impute$term)+1 #set 1 as the first post-treatment period
to_plot <- as.data.frame(model.impute)
esplot(data=to_plot,Period = "term",Estimate = 'estimate',SE = 'std.error',xlim = c(-12,10))
out.impute
```


### Compare with PanelMatch

To compare the results with those obtained via the **PanelMatch** method, **fect** also provides the capability to compute the ATT for the subset of the sample that includes units with 3 pre-treatment periods and 4 post-treatment periods. This can be achieved by specifying the option balance.period = c(-2,4), which denotes the range of periods to be included in the analysis (-2, -1, and 0 for pre-treatment, and 1, 2, 3, and 4 for post-treatment).

```{r hh_balance, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
out.fect.balance <- fect(nat_rate_ord~indirect, data = df, index = c("bfs","year"),
                         method = 'fe', se = TRUE, balance.period = c(-2,4))
#ATT
print(out.fect.balance$est.balance.avg)
#Dynamic Treatment Effects
```

```{r hh_balance2, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=FALSE}
fect.balance.output <- as.data.frame(out.fect.balance$est.balance.att)
fect.balance.output$Time <- c(-2:4)
p.fect.balance <- esplot(fect.balance.output,Period = 'Time',Estimate = 'ATT',
                   SE = 'S.E.',CI.lower = "CI.lower", 
                   CI.upper = 'CI.upper')
p.fect.balance
```



## Sensitivity Analyses and Robust Confidence Set

@rambachan2023more introduce a robust inference method that tolerates violations of the parallel trend assumption (PTA), provided that deviations in post-treatment periods do not exceed those observed in the pre-treatment phase. This method is useful for sensitivity analysis of estimates from **FEct** and other models. We demonstrate two approaches for this analysis: one using estimated coefficients from all 15 pre-treatment periods and another using coefficients from three specific placebo periods. The commands `createSensitivityResults_relativeMagnitudes` and `constructOriginalCS` from the **Honestdid** package are utilized to construct these robust confidence intervals.

For the first approach, we start with extracting event-study coefficients of all pre-treatment periods and their variance-covariance matrix from FEct's output. By setting a threshold $\bar{M}$, we allow deviations in post-treatment periods as long as they are less than $\bar{M}$ times the maximum difference between consecutive pre-treatment period coefficients. We generate confidence intervals for the ATT by varying $M$ from 0.1 to 0.5, thus adjusting the allowed level of post-treatment deviations. The `l_vec` option dictates the relative weights of post-treatment coefficients in estimating ATT, proportional to the observation count in each period. Notably, at $M=0.3$, the confidence interval's lower bound remains slightly above zero, but at $M=0.4$, the confidence interval includes zero. This suggests we can still reject the null hypothesis of no treatment effect when deviations in post-treatment periods do not exceed $0.3$ times the maximum difference between consecutive pre-treatment period coefficients.


```{r hh_honest_fect, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=TRUE}
# obtain the estimated beta and estimated vcov matrix from the output of FEct
index.use <- which(rownames(out.fect$est.att) %in% as.character(c(-14:10)))
beta.hat <- out.fect$est.att[index.use,1]
vcov.hat <- out.fect$att.vcov[index.use,index.use]
count <- out.fect$count[which(rownames(out.fect$est.att) %in% as.character(c(1:10)))]

# construct the robust confidence intervals under M=0.1,...,0.5.
honest.result <- createSensitivityResults_relativeMagnitudes(betahat = beta.hat,
                                                             sigma = vcov.hat,
                                                             numPrePeriods = 15,
                                                             numPostPeriods = 10,
                                                             l_vec = count/sum(count),
                                                             Mbarvec = seq(0.1,0.5,by=0.1)) 

# construct the robust confidence intervals under M=0
originalResults <- constructOriginalCS(betahat = beta.hat,
                                       sigma = vcov.hat,
                                       numPrePeriods = 15,
                                       numPostPeriods = 10,
                                       l_vec = count/sum(count))

createSensitivityPlot_relativeMagnitudes(honest.result, originalResults)

```


By modifying the `l_vec` option, we can also obtain separate confidence intervals for each post-treatment period. In the figure below, we apply the same command with $\bar{M}=0.5$ to derive robust confidence intervals. These intervals allow deviations from the parallel trend assumption in post-treatment periods, provided they remain smaller than 0.5 times the maximum deviation observed between two consecutive pre-treatment event study coefficients. These robust confidence intervals are depicted in dark red in the figure.

```{r hh_honest_fect_dte, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
T.post <- 10
dte_base <- rep(0,T.post)
dte_output <- cbind.data.frame(lb = c(), 
                               ub = c(), 
                               method = c(), 
                               Delta = c(), 
                               Mbar = c(),
                               post = c())

for(t.post in c(1:T.post)){
  dte_l <- dte_base
  dte_l[t.post] <- 1
  honest.dte <- createSensitivityResults_relativeMagnitudes(betahat = beta.hat,
                                                            sigma = vcov.hat,
                                                            numPrePeriods = 15,
                                                            numPostPeriods = T.post,
                                                            l_vec = dte_l,
                                                            Mbarvec = c(0,0.5))
  
  honest.dte <- as.data.frame(honest.dte)
  honest.dte$post <- t.post
  dte_output <- rbind(dte_output,honest.dte)
}

```


```{r hh_honest_fect_dte_vis, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5}
dte_output <- as.data.frame(dte_output)
p.fect.honest <- esplot(fect.output,Period = 'Time',Estimate = 'ATT',
                   SE = 'S.E.',CI.lower = "CI.lower", main = "FEct",ylab = "Coefficients and 95% CI",
                   CI.upper = 'CI.upper',xlim = c(-12,10),ylim = c(-6,8),Count = 'count',show.count = T)

p.fect.honest <- p.fect.honest + geom_linerange(aes(x=post,ymin=lb,ymax=ub),data = dte_output[which(dte_output$Mbar==0.5),],color = 'maroon',size=1.2)
p.fect.honest <- p.fect.honest + geom_linerange(aes(x=post,ymin=lb,ymax=ub),data = dte_output[which(dte_output$Mbar==0),],color = 'black',size=1.2)
p.fect.honest
```


We can also apply the above procedure to event-study results derived from other estimators, provided their pre-treatment coefficients and variance-covariance matrices are available. Another concern, highlighted by @roth2024interpreting, is that some HTE-robust estimators produce pre-treatment and post-treatment coefficients asymmetrically, necessitating cautious interpretation by researchers. For instance, in the CSDID section, omitting the `base_period = "universal"` option exposes us to this risk.

This concern about asymmetry motivates a second approach to obtaining robust confidence intervals. We remove observations in specified placebo periods within pre-treatment for model fitting, impute the counterfactual for these and the post-treatment periods, and calculate the event-study coefficients. This method ensures symmetric generation of coefficients for both post-treatment and placebo periods. By setting a threshold $\bar{M}$, we allow deviations in post-treatment periods as long as they are less than $\bar{M}$ times the maximum difference between consecutive placebo period coefficients. FEct includes built-in functionality for this placebo test. We can set `placeboTest = TRUE` and `placebo.period = c(-2, 0)`, which defines the placebo periods as the three periods immediately preceding treatment onset. After obtaining the coefficients and variance-covariance matrix for the placebo and post-treatment periods, we can generate the robust confidence interval in the same manner as previously described. The result suggests we can still reject the null hypothesis of no treatment effect when deviations in post-treatment periods do not exceed $0.6$ times the maximum difference between consecutive placebo period coefficients.

```{r, hh_honest_placebo,warning=FALSE, message=FALSE,cache=TRUE}
out.fect.placebo <- fect(nat_rate_ord~indirect, data = df, index = c("bfs","year"),
                         method = 'fe', se = TRUE, 
                         placeboTest = TRUE, placebo.period = c(-2,0))
```

```{r,hh_honest.placebo.honest,   fig.width = 7, fig.height = 5,  cache=TRUE}
index.use <- which(rownames(out.fect.placebo$est.att) %in% as.character(c(-2:T.post)))
beta.hat.p<- out.fect.placebo$est.att[index.use,1]
vcov.hat.p <- out.fect.placebo$att.vcov[index.use,index.use]
count <- out.fect.placebo$count[which(rownames(out.fect.placebo$est.att) %in% as.character(c(1:T.post)))]

honest.result.p <- createSensitivityResults_relativeMagnitudes(betahat = beta.hat.p,
          sigma = vcov.hat.p,
          numPrePeriods = 3,
          numPostPeriods = T.post,
          l_vec = count/sum(count),
          Mbarvec = seq(0.2,1,by=0.2)) 

originalResults.p <- constructOriginalCS(betahat = beta.hat.p,
           sigma = vcov.hat.p,
           numPrePeriods = 3,
           numPostPeriods = T.post,
           l_vec = count/sum(count))

createSensitivityPlot_relativeMagnitudes(honest.result.p, originalResults.p)
```


By modifying the `l_vec` option, we can also obtain separate confidence intervals for each post-treatment period similarly. In the figure below, we use the same command with $\bar{M}=0.5$ to derive robust confidence intervals using coefficients from the placebo periods. We depict the placebo periods in blue and the robust confidence intervals in pink.


```{r,hh_honest.placebo.honest.gap,   fig.height=4, fig.width=8, fig.align='center', cache=TRUE}
dte_base <- rep(0,T.post)
dte_output <- cbind.data.frame(lb = c(), 
                               ub = c(), 
                               method = c(), 
                               Delta = c(), 
                               Mbar = c(),
                               post = c())

for(t.post in c(1:T.post)){
  dte_l <- dte_base
  dte_l[t.post] <- 1
  honest.dte <- createSensitivityResults_relativeMagnitudes(betahat = beta.hat.p,
                                                            sigma = vcov.hat.p,
                                                            numPrePeriods = 3,
                                                            numPostPeriods = T.post,
                                                            l_vec = dte_l,
                                                            Mbarvec = c(0,0.5))
  
  honest.dte <- as.data.frame(honest.dte)
  honest.dte$post <- t.post
  dte_output <- rbind(dte_output,honest.dte)
}

```

```{r,hh_honest.placebo.honest.gap.p, warning=FALSE,  fig.width = 7, fig.height = 5, cache = FALSE}
fect.output.p <- as.data.frame(out.fect.placebo$est.att)
fect.output.p$Time <- as.numeric(rownames(fect.output.p))
p.placebo.honest <- esplot(fect.output,Period = 'Time',Estimate = 'ATT',
                   SE = 'S.E.',CI.lower = "CI.lower", main = "FEct",ylab = "Coefficients and 95% CI",
                   CI.upper = 'CI.upper',xlim = c(-12,10),ylim = c(-6,8),Count = 'count',show.count = T)
dte_output <- as.data.frame(dte_output)

p.placebo.honest <- p.placebo.honest + geom_linerange(aes(x=post,ymin=lb,ymax=ub),data = dte_output[which(dte_output$Mbar==0.5),],color = 'maroon1',linewidth = 1)
p.placebo.honest <- p.placebo.honest + geom_linerange(aes(x=post,ymin=lb,ymax=ub),data = dte_output[which(dte_output$Mbar==0),],color = 'black',linewidth = 1)
p.placebo.honest <- p.placebo.honest + geom_linerange(aes(x=Time,ymin=CI.lower,ymax=CI.upper),data = fect.output.p[which(fect.output.p$Time%in%c(-2:0)),],color = 'blue',linewidth = 1)
p.placebo.honest
```



# Example 2: w/ Treatment Reversal

We utilize the data from @Grumbach2020 to demonstrate the analysis procedure when the treatment can switch on and off. The study, which uses district-election year level TSCS data from US House general elections between 1980 and 2012, argues that the presence of Asian (Black/Latino) candidates in general elections leads to an increase in the proportion of campaign contributions by Asian (Black/Latino) donors. Specifically, we focus on the effects of Asian candidates as presented in the top left panel of Figure 5 in the paper.

```{r message = FALSE, warning = FALSE}
data <- gs2020
data$cycle <- as.integer(as.numeric(data$cycle/2))
head(data)
```

##  Data Visualization

In our analysis, the variable `district_final` and `cycle` serve as the unit and time index, respectively. The treatment variable is `cand_A_all`, the outcome of interest is `general_sharetotal_A_all`, and the covariates included in the analysis are `cand_H_all` and `cand_B_all`. To gain insight into the treatment conditions and missing values in the data, we utilize the **panelView** package. The option `by.timing = TRUE` is set in order to organize the units based on the timing of receiving the treatment. It should be noted that this dataset includes missingness in the outcome variable and the treatment may switch on and off.

```{r gb_panelview_treat, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=TRUE}
y <- "general_sharetotal_A_all"
d <- "cand_A_all"
unit <- "district_final"
time <- "cycle"
controls <- c("cand_H_all", "cand_B_all")
index <- c("district_final", "cycle")

panelview(Y=y, D=d, X=controls, index = index, data = data, xlab = "Time Period", ylab = "Unit", 
          gridOff = TRUE, by.timing = TRUE, cex.legend=5, cex.axis= 5, cex.main = 10, cex.lab = 5)

```

##  TWFE

First, we obtain the ATT using the TWFE estimator.

```{r gb_twfe1, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
model.twfe <- feols(general_sharetotal_A_all ~ cand_A_all + cand_H_all + cand_B_all|district_final + cycle,
                    data=data, cluster = "district_final") #use the clustered standard error
print(model.twfe)
```

### Event Study Plot

To estimate the dynamic treatment effects, we first utilize the function `get.cohort` to obtain the relative period to the treatment. We then generate the treated unit indicator `treat` by following these steps: First, we set `treat = 0` for observations of units that have never been treated. Second, for units that have been treated, if the treatment switches on and off, we only set `treat = 1` for observations prior to the last treatment exit, i.e., if a unit has the treatment status sequence as 0, 0, 0, 1, 1, 0, 0, we only set `treat = 1` for the first five observations. This procedure assumes no carryover treatment effects, meaning that the treatment only takes effect at the current period. Finally, we interact the dummy variable `treat` with the relative period index in a two-way fixed effects regression to estimate the dynamic treatment effects.

```{r gb_twfe2, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
data_cohort <- get.cohort(data, index = index, D=d,start0 = TRUE)
# Generate a dummy variable treat
data_cohort$treat <- 0
data_cohort[which(data_cohort$Cohort!='Control'),'treat'] <- 1
data_cohort[which(is.na(data_cohort$Time_to_Treatment)), "treat"] <- 0

# remove observations that starts with treated status
remove <- intersect(which(is.na(data_cohort$Time_to_Treatment)), which(data_cohort[,d]==1)) 
if(length(remove)>0){data_cohort <- data_cohort[-remove,]}

# replace missingness in Time_to_Treatment with an arbitrary number
data_cohort[which(is.na(data_cohort$Time_to_Treatment)), "Time_to_Treatment"] <- 999 

twfe.est <- feols(general_sharetotal_A_all ~ i(Time_to_Treatment, treat, ref = -1) + 
                  cand_H_all +cand_B_all | district_final + cycle,  
                  data = data_cohort, cluster = "district_final")
```

We then visualize the estimated dynamic treatment. 

```{r gb_twfeplot, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
twfe.output <- as.matrix(twfe.est$coeftable[c(1:25),])
print(twfe.output)
```

```{r gb_twfeplot2, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=FALSE}
twfe.output <- as.data.frame(twfe.output)
twfe.output$Time <- c(c(-16:-2),c(0:9))+1 
p.twfe <- esplot(twfe.output,Period = 'Time',Estimate = 'Estimate',
                               SE = 'Std. Error', xlim = c(-15,1))
p.twfe
```



## PanelMatch

PanelMatch is also equipped to handle scenarios where the treatment can switch on and off. In this case, we will utilize a subset of the treated units that have two pre-treatment periods and one post-treatment period to calculate the average treatment effects.

```{r gb_pm, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
df.pm <- data_cohort
# we need to convert the unit and time indicator to integer
df.pm[,"district_final"] <- as.integer(as.factor(df.pm[,"district_final"]))
df.pm[,"cycle"] <- as.integer(as.factor(df.pm[,"cycle"]))
df.pm <- df.pm[,c("district_final","cycle","cand_A_all","general_sharetotal_A_all")]

PM.results <- PanelMatch(lag=2, 
                         time.id="cycle", 
                         unit.id = "district_final", 
                         treatment = "cand_A_all", 
                         refinement.method = "none", 
                         data = df.pm, 
                         qoi = "att", 
                         lead = 0, 
                         outcome.var = "general_sharetotal_A_all", 
                         match.missing = TRUE)

## For pre-treatment dynamic effects
PM.results.placebo <- PanelMatch(lag=2, 
                         time.id="cycle", 
                         unit.id = "district_final", 
                         treatment = "cand_A_all", 
                         refinement.method = "none", 
                         data = df.pm, 
                         qoi = "att", 
                         lead = 0, 
                         outcome.var = "general_sharetotal_A_all", 
                         match.missing = TRUE,
                         placebo.test = TRUE)

```


```{r gb_pm1, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
# ATT
PE.results.pool <- PanelEstimate(PM.results, data = df.pm, pooled = TRUE)
summary(PE.results.pool)$summary
```

### Event Study Plot

We obtain the dynamic treatment effects in the same way as we showed in the case of @hainmueller2019does.

```{r gb_pm2, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
# Dynamic Treatment Effects
PE.results <- PanelEstimate(PM.results, data = df.pm)
PE.results.placebo <- placebo_test(PM.results.placebo, data = df.pm, plot = F)
```

```{r gb_pm3, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=FALSE}
est_lead <- as.vector(PE.results$estimates)
est_lag <- as.vector(PE.results.placebo$estimates)
sd_lead <- apply(PE.results$bootstrapped.estimates,2,sd)
sd_lag <- apply(PE.results.placebo$bootstrapped.estimates,2,sd)
coef <- c(est_lag, 0, est_lead)
sd <- c(sd_lag, 0, sd_lead)
pm.output <- cbind.data.frame(ATT=coef, se=sd, t=c(-1:1))
p.pm <- esplot(data = pm.output,Period = 't',
               Estimate = 'ATT',SE = 'se')
p.pm
```


## Imputation Method

The stacked DiD, iw estimator and csdid estimator do not account for treatment reversals. To estimate the average treatment effect (ATT) in scenarios where treatment can switch on and off, we employ the imputation method proposed by @LWX2022, which accounts for treatment reversals and heterogeneous treatment effects.

```{r gb_fect, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
model.fect <- fect(Y = y, D = d, X= controls, data = data, 
                   method = "fe", 
                   index = index, se = TRUE, parallel = TRUE, seed = 1234, force = "two-way")
print(model.fect$est.avg)
```


### Event Study Plot

We visualize the estimated dynamic treatment for the counterfactual estimator in the same way. 

```{r gb_fectplot, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
fect.output <- as.matrix(model.fect$est.att)
print(fect.output)
```

```{r gb_fectplot2, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=FALSE}
fect.output <- as.data.frame(fect.output)
fect.output$Time <- c(-15:10)
p.fect <- esplot(fect.output,Period = 'Time',Estimate = 'ATT',
                   SE = 'S.E.',CI.lower = "CI.lower", 
                   CI.upper = 'CI.upper', xlim = c(-15,1))
p.fect
```

The **plot** function shipped with **fect** can also visualize the estimated dynamic treatment effects.

```{r gb_fectplot3, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=TRUE}
plot(model.fect, stats = "F.p")
```

An $F$-test for the null hypothesis of zero residual averages in the pre-treatment periods yields a p-value greater than 0.1, providing insufficient evidence to reject the null hypothesis of zero pre-treatment average residuals.

We can visualize the period-wise ATTs relative to the **exit** of treatments by setting `type = "exit"`.

```{r gb_fectplot4, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=TRUE}
plot(model.fect, stats = "F.p", type = 'exit')
```


### Diagnostic Tests


**Fect** also offers a placebo test function, which utilizes a subset of the data by removing observations in a specified range for model fitting, and subsequently assessing whether the estimated average treatment effect (ATT) in this range is statistically significant from zero. In this instance, we have set `placebo.period = c(-2, 0)`, indicating that the placebo periods will consist of the three periods preceding the onset of treatment.

```{r hh_fectplacebo, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=TRUE}
out.fect.p <- fect(Y = y, X = controls, D = d, data = data, index = index,
                   method = 'fe', se = TRUE, placeboTest = TRUE, placebo.period = c(-2,0))
p.placebo <- plot(out.fect.p, proportion = 0.1, stats = "placebo.p")
p.placebo
```

***Test for (No) Carryover Effects***

The concept of the placebo test can be extended to examine the existence of carryover effects. Rather than obscuring a few periods immediately preceding the onset of treatment, this method involves obscuring a few periods immediately following the termination of treatment. If carryover effects do not exist, one would expect the average prediction error in these periods to be close to zero. To perform the carryover test, the option `carryoverTest = TRUE` is set. Additionally, a range of post-treatment periods can be specified in the option `carryover.period` to remove observations from this range for the purposes of model fitting, and then test whether the estimated Average Treatment Effect (ATT) in this range is significantly different from zero.

```{r gb_fectcarryover, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=TRUE}
out.fect.c <- fect(Y = y, X = controls, D = d, data = data, index = index,
                   method = 'fe', se = TRUE, carryoverTest = TRUE, carryover.period = c(1,2))
p.carryover <- plot(out.fect.c,  stats = "carryover.p")
p.carryover
```

### Compare with PanelMatch

We can compare it with the estimated ATT and dynamic treatment effects on the "balanced" sample using **fect**.

```{r gb_balance, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 4.5, cache=TRUE}
out.fect.balance <- fect(Y = y, X = controls, D = d, data = data, index = index,
                         method = 'fe', se = TRUE, balance.period = c(-1,1))
#ATT
print(out.fect.balance$est.balance.avg)
#Dynamic Treatment Effects
```

```{r gb_balance2, message = FALSE, warning = FALSE, fig.width = 7, fig.height = 5, cache=FALSE}
fect.balance.output <- as.data.frame(out.fect.balance$est.balance.att)
fect.balance.output$Time <- c(-1:1)
p.fect.balance <- esplot(fect.balance.output,Period = 'Time',Estimate = 'ATT',
                   SE = 'S.E.',CI.lower = "CI.lower", 
                   CI.upper = 'CI.upper')
p.fect.balance
```


# Reference
